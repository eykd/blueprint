"""Blueprint collections for on-demand generation.

This module provides the BlueprintCollection class, which wraps Blueprint classes
to enable lazy, on-demand generation of blueprint instances. Collections implement
both Sequence and Callable protocols, allowing flexible access patterns including
indexing, slicing, and parameterized generation.

Collections are particularly useful for:
    - Generating series of related blueprints with deterministic seeds
    - Creating infinite sequences of procedurally generated content
    - Parameterizing blueprint generation with consistent defaults

Example:
    >>> from blueprint.base import Blueprint
    >>> class Item(Blueprint):
    ...     name = 'sword'
    >>> items = BlueprintCollection(Item, seed='treasure')
    >>> items[0].name
    'sword'
    >>> items[5].name
    'sword'

"""

import itertools as it
import sys
from collections.abc import Generator, Iterator, Sequence
from typing import Any, overload

from blueprint.base import Blueprint

__all__ = ['BlueprintCollection']


class BlueprintCollection(Sequence[Blueprint]):
    """A collection that generates blueprint instances on demand.

    This class implements both Sequence and Callable protocols to provide
    flexible access to blueprint instances. It can be called to generate
    blueprints with custom parameters, or indexed/sliced to generate
    blueprints with deterministic seeds.

    The collection supports multiple access patterns:
        - Indexing: ``collection[n]`` generates blueprint with seed ``"{base_seed}{n}"``
        - Slicing: ``collection[start:stop]`` generates list of blueprints
        - Infinite slicing: ``collection[start:]`` generates infinite iterator
        - Calling: ``collection(seed='custom')`` generates with explicit parameters

    Attributes:
        blueprint: The Blueprint class to instantiate.
        seed: Base seed string used for deterministic generation.
        kwargs: Default keyword arguments passed to blueprint instances.

    Example:
        >>> from blueprint.base import Blueprint
        >>> class Weapon(Blueprint):
        ...     damage = 10
        >>> weapons = BlueprintCollection(Weapon, seed='weapon')
        >>> weapons[0].damage
        10
        >>> weapons[5].damage
        10
        >>> # Generate with custom seed
        >>> special = weapons(seed='legendary')
        >>> # Get first 3 weapons
        >>> first_three = weapons[0:3]
        >>> len(first_three)
        3

    """

    blueprint: type[Blueprint]
    seed: str
    kwargs: dict[str, Any]

    def __init__(self, blueprint: type[Blueprint], seed: str = '', **kwargs: Any) -> None:  # noqa: ANN401
        """Initialize a blueprint collection.

        Args:
            blueprint: The Blueprint class to instantiate.
            seed: Base seed string for deterministic generation. Defaults to empty string.
                When accessing by index, this seed is combined with the index to create
                unique but deterministic seeds for each blueprint instance.
            **kwargs: Additional keyword arguments to pass to all blueprint instances
                generated by this collection. These can be overridden in individual
                calls to the collection.

        Example:
            >>> from blueprint.base import Blueprint
            >>> class Item(Blueprint):
            ...     name = 'item'
            ...     quantity = 1
            >>> # Create collection with default quantity
            >>> items = BlueprintCollection(Item, seed='loot', quantity=5)
            >>> items[0].quantity
            5

        """
        self.blueprint = blueprint
        self.seed = seed
        self.kwargs = kwargs

    def __len__(self) -> int:
        """Return the theoretical maximum size of the collection.

        Returns:
            sys.maxsize (the maximum integer value) since the collection can
            generate blueprints on demand indefinitely.

        Note:
            This collection is conceptually infinite, but returns sys.maxsize
            to satisfy the Sequence protocol. In practice, memory and time
            constraints limit actual usage.

        """
        return sys.maxsize

    def __iter__(self) -> Iterator[Blueprint]:  # pragma: no cover
        """Return an iterator over the collection.

        Returns:
            An infinite iterator that generates blueprint instances starting from
            index 0. Each blueprint is generated with a deterministic seed based
            on its position in the sequence.

        Warning:
            This iterator is infinite and will generate blueprints indefinitely.
            Use with care in contexts that expect finite sequences (e.g., list()).

        Example:
            >>> from blueprint.base import Blueprint
            >>> import itertools
            >>> class Item(Blueprint):
            ...     value = 10
            >>> items = BlueprintCollection(Item)
            >>> # Take first 3 items from infinite iterator
            >>> first_three = list(itertools.islice(items, 3))
            >>> len(first_three)
            3

        """
        return iter(self[0:])

    def __contains__(self, item: object) -> bool:
        """Check if an item is in the collection.

        Args:
            item: Any object to check for membership.

        Returns:
            Always returns True since the collection is conceptually infinite
            and can generate any blueprint instance on demand.

        Note:
            This implementation satisfies the Sequence protocol but doesn't
            perform actual membership testing. In an infinite collection,
            membership is considered universal.

        """
        return True

    def __call__(
        self,
        parent: Blueprint | None = None,
        seed: str | None = None,
        **kwargs: Any,  # noqa: ANN401
    ) -> Blueprint:
        """Generate a blueprint instance with the given parameters.

        This method allows the collection to be called like a function, providing
        explicit control over blueprint generation parameters. Any kwargs passed
        here override the collection's default kwargs.

        Args:
            parent: Optional parent blueprint for the generated instance.
            seed: Optional seed override. If not provided, uses the collection's
                base seed. This allows generating blueprints with custom seeds
                outside the index-based deterministic sequence.
            **kwargs: Additional keyword arguments merged with the collection's
                default kwargs. These override collection defaults on a per-call basis.

        Returns:
            A mastered blueprint instance with all fields resolved.

        Example:
            >>> from blueprint.base import Blueprint
            >>> class Weapon(Blueprint):
            ...     name = 'sword'
            ...     damage = 10
            >>> weapons = BlueprintCollection(Weapon, seed='weapon', damage=15)
            >>> # Use collection defaults
            >>> w1 = weapons()
            >>> w1.damage
            15
            >>> # Override with custom parameters
            >>> w2 = weapons(damage=20, seed='legendary')
            >>> w2.damage
            20

        """
        options: dict[str, Any] = {}
        options.update(self.kwargs)
        options.update(kwargs)
        return self.blueprint(parent=parent, seed=seed if seed is not None else self.seed, **options)

    @overload
    def __getitem__(self, idx: int) -> Blueprint: ...

    @overload
    def __getitem__(self, idx: slice) -> Sequence[Blueprint]: ...

    def __getitem__(self, idx: int | slice) -> Blueprint | Sequence[Blueprint] | Generator[Blueprint, None, None]:
        """Get blueprint(s) by index or slice.

        This method supports three access patterns with deterministic seeding:
        - Integer indexing generates a single blueprint with seed ``"{base_seed}{idx}"``
        - Bounded slicing generates a list of blueprints for the specified range
        - Unbounded slicing generates an infinite iterator of blueprints

        Args:
            idx: Integer index or slice object. When using slices, the step parameter
                controls the increment between generated indices.

        Returns:
            - For integer index: A single mastered blueprint instance with seed
              based on the index value.
            - For slice with stop value: A list of mastered blueprint instances,
              one for each index in the range.
            - For slice without stop value (e.g., ``[5:]``): An infinite generator
              yielding mastered blueprint instances.

        Example:
            >>> from blueprint.base import Blueprint
            >>> class Item(Blueprint):
            ...     name = 'item'
            >>> items = BlueprintCollection(Item, seed='treasure')
            >>> # Get single item
            >>> item_0 = items[0]
            >>> item_0.name
            'item'
            >>> # Get finite range
            >>> items_list = items[0:3]
            >>> len(items_list)
            3
            >>> # Get every other item in a range
            >>> items_step = items[0:10:2]
            >>> len(items_step)
            5
            >>> # Get infinite generator starting at index 5
            >>> import itertools
            >>> infinite_items = items[5:]
            >>> next(infinite_items).name
            'item'

        """
        if isinstance(idx, slice):
            seed = f'{self.seed}%s'
            if idx.stop is None:
                return (self(seed=seed % i, **self.kwargs) for i in it.count(idx.start or 0, idx.step or 1))
            return [self(seed=seed % i) for i in range(idx.start or 0, idx.stop, idx.step or 1)]
        seed = f'{self.seed}{idx}'
        return self(seed=seed)
